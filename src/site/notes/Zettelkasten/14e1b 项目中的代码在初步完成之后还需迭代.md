---
{"dg-publish":true,"permalink":"/Zettelkasten/14e1b 项目中的代码在初步完成之后还需迭代/","dgPassFrontmatter":true}
---

编号:: 14e1b
标题:: 项目中的代码在初步完成之后还需迭代
创建时间:: 2023-07-20 10:34
up:: [[Zettelkasten/14e1 代码注定变成“屎山”\|14e1 代码注定变成“屎山”]]
来源:: 《代码大全》

---
我们编写的代码之后还会被大量的阅读，因此在编写的时候应该尽量提高代码的可读性。因为人脑智力是有限的，所以我们需要对项目工程中的复杂度进行管理。《代码大全》从如何取变量名、选取何种数据结构等编程基本要素，到如何组织语句顺序、设计循环等结构设计，最后到子程序和类的设计、代码调整策略和方法都有着非常具体地介绍。所谓的复杂度管理，就是尽可能降低项目中的复杂度，让代码的作者和使用者都能轻易弄懂代码的真实意图。
**提高代码的可读性**，因为代码总归是写给自己和协作者看的，为了之后便于修改和扩展，提高代码的可读性能降低之后的维护成本和错误率。
**将项目进行分割**，作者提出人类脑力有限，一次只能高效处理小部分工作，那我们就需要对项目进行分割。从代码语句级别来说我们要尽力减短变量的生命周期，让人们注意力集中在代码的一小段。从子程序和类的设计来说，我们需要做到高内聚。每个子程序只完成一个特定的任务，每个类中的子程序完成的任务都是紧密相关的。


## **高质量变量名**

一个好的变量名应该是可读、易记、和名副其实的。变量名要完全、准确、描述该变量所代表的事务。

一些含义模糊、模棱两可的变量名往往不可取，我在以往的项目中经常使用像是x、temp、i 、flag这些变量名，实际上是我自己没有花时间想出一个更符合变量的名字，所以图省事才定义了这些变量名。

不要用简单的数字后缀区分变量，以前经常会定义出x1和x2这样的变量名，即使自己知道了x代表的含义，也无法获知x1和x2之间的关系。

### **合理的变量名长度**

《代码大全》事无巨细，甚至给出了研究数据表明合适的变量长度应该是在10到16个字符之间，它想要强调的是如果我们变量名很短的时候，就应该考虑我们的变量名是否足够清晰。当然很短的变量名更适合于局部变量或者循环变量。像是i、j、k 这些变量名一看就是循环计数器或者说是数组下标。

### **合理使用限定词**

变量名中推荐使用限定词，像是表示计算结果的变量：总额、平均值、最大值，可以用Total、Sum、Max这样的限定词放在变量名最后。这样我们首先见到是变量名中最重要的那部分而不是限定词，而且后置限定词能够让我们的代码保持一致性、避免歧义、简化维护工作。不过值得注意的是，像是表达数字的Num限定词往往会放在变量名前面充当前缀，当Num限定词作为后缀的时候，往往代表一个下标。

### **为循环下标命名**

循环结构使用的频率非常高，以至于我们常常会使用约定俗成的循环下标名，像是i、j、k。但如果在复杂循环像是深层嵌套循环中，我们可能会忘记i、j、k原来的含义，不便于代码的修改和扩展以及复用，有的时候甚至会出现下标串话。想用i的时候用的是j，想用j的时候用的是i。

```text
for (teamIndex = 0; teamIndex < teamCount; teamIndex++){
    for (enventIndex = 0; enventIndex < enventCount; enventIndex++){
        // do something with score[teamIndex][enventIndex]    
    }
}
```

以上代码中score\[teamIndex\]\[enventIndex\]表达的含义要比score\[i\]\[j\]更清楚。

### **为临时变量命名**

程序中经常出现一些计算的中间结果，之前我往往会比较随意地对待这些值，常常取名为temp、x但是这些变量名往往无法准确地表达其含义。像是求一元二次方程根的部分代码：

```text
temp = sqrt(b^2 - 4*a*c);
root[0] = (-b + temp) / (2 * a);
root[1] = (-b - temp) / (2 * a);
```

因为我们之后还会用到表达式sqrt(b^2 - 4\*a\*c)，所以将该表达式的结果保存在一个临时变量中，但是该变量名没有反映该变量的功能。如果**将temp转换为discrimnant将会更合适**。如果我们一直将中间变量取名为temp，那么在同一个文件中出现多个中间变量时，我们可能会设置多个temp1,temp2 那么很容易将这些变量搞混，造成错误。

### **为布尔变量命名**

在为布尔变量命名之时，我们给布尔变量赋予含有“真假”含义的名字。像是status这样的布尔变量名有些糟糕，因为没有明确的true或者false状态。status为true代表状态ok吗？还是status为false代表没有错误。

《代码大全》给出了一些经典的布尔变量名：done、error、found、success、ok。

之前我自己命名时还会取isOk这样的布尔变量名，但是在条件判断语句中if(isOk)没有if(Ok)来的清晰明了。所以布尔变量名中也不需要加is前缀。

## **关于数据类型使用的建议**

《代码大全》在数据类型的使用上也给出了很翔实的建议。主要是**提高代码的可维护性和降低出错的可能性**。

### **避免直接使用数值文字量**

这个建议指的是不要在代码中使用未经解释的数值文字量。就像是循环结构中出现的循环总数100,

```text
for (int i=0; i<100; i++) {
    # do somethiong
}
 # do somethiong with 100
```

我们在之后的程序中可能还会多次使用到这个循环总数100。如果我们需要进行修改的话会很麻烦，因为要在多个地方进行修改，如果有遗漏的话还会造成程序出错。

```text
loopCnt = 100;
for (int i=0; i<loopCnt; i++) {
    # do somethiong
}
 # do somethiong with loopCnt
```

如果我们使用一个变量来接受该数值的话，修改会变得可靠和简单，可读性也会更强。

### **整数**

在使用整数的时候要尽量考虑两个问题：

**注意整数除法**。除了要注意除数不能为0之外，还要注意除法向下取整的问题。

**注意整数溢出**。在做整数的加法和乘法的时候，要注意运算结果是否超过整数的最大值，当运算结果超出整数最大值的时候，便会溢出。

以上两种情况都会导致运算结果和预计的不一样，导致编程错误。

### **浮点数**

因为计算机中，无法足够精确地表示很多十进制小数，所以在使用浮点数的时候，也因该遵循以下的指导原则，避免程序错误。

**避免数量级相差巨大的数之间的加减运算**。因为32位浮点变量，1000000.00+0.1可能会得到1000000.00，因为32位没有足够的有效位包容1000000.00和0.1之间的区间。我们在相加一系列差异巨大的浮点数值的时候，最好将这系列数进行排序，从最小值开始相加。虽然不能从根本上消除舍入问题，但是还是能将这一问题的影响减到最小。

**避免等量判断**。
有的时候用不同的方法求到的同一浮点数值，虽然在现实世界中相等，但是在计算机中直接用\==比较的话，却是不相等。对应的解决办法是写一个equals()函数，在函数中将两数相减，当相差足够小就返回true，否则返回false。

### **数组**

数组是最简单和最常使用的结构化数据类型，在使用数组时候，应当注意以下几点，避免程序错误。

**确认数组下标不会超出数组的边界**。数组下标越界是经常发生的错误。

**确认多维数组下标是否使用正确**。因为在使用多维度数组的时候，很容易将下标搞混，也就是**下标串话**，所以最好别将多维数组下标命名为i、j、k 而是更有可读性的名字

## **如何让合理组织代码结构**

《代码大全》中提到，有先后顺序的合理地放置语句和代码块，能够提高代码质量、正确性和可维护性。在冗长的代码中，按照依赖关系强弱将代码合理划分，能够让程序员每次只将注意力集中在某一区间，避免了程序员在一个文件中上下查找。

### **有明确顺序的代码**

有明确顺序的代码是指，语句之间有明确的依赖性。例如，第三句语句依赖第二句，第二句依赖第一句。这样的连续语句是非常容易组织的。

```text
data = ReadData();
result = CaculateResultFromData(data);
ptintResult(result);
```

在计算数据之前，必须先读入数据。在打印结果之前，也必须要计算结果。

对于这种有明显依赖关系的语句，我们要做的就是设法**将这些依赖关系变得明显**。这样的代码阅读起来会非常紧密，后续修改和扩展时，也会知道不应该修改这些代码之间的顺序。主要的方法总结为以下几点：

-   **利用子程序名凸显依赖关系**。
-   **利用程序参数明确显示依赖关系**。
-   **利用注释对不清晰的依赖关系进行说明**。
-   **用断言或者错误处理代码来检查错误关系**。例如在类的构造函数中将某个成员变量设置为false，在初始化函数中将该成员变量设置为true，每一个依赖初始化函数的函数都会检查该成员变量是否被设置为true。

### **没有明确顺序的代码**

当代码中的若干语句或者代码块的先后顺序没有严格的依赖关系时，但是代码顺序仍然对代码可读性、可维护性有影响，而且缺少执行顺序的依赖关系时，我们可以**按照代码相关性**来组织结构。主要的原则总结为以下两点：

-   **使代码易于自上而下阅读**。这是一条普适性的原则，不让程序员的目光在文件中跳来跳去，能够顺着代码自然地从上而下阅读。尽可能减短每个变量的生存期，这里的变量生存是变量从定义开始到结束引用之间的代码行数，生存期越短，程序员的目光就越能集中。
-   **把相关语句组织在一起**。让联系性强的代码处于一个区间，每个联系不强的代码块之间可以留出空行加以区分。

## **关于循环结构使用的建议**

### **选择合适的循环结构**

在循环次数固定的情况下使用for循环，值得注意的是不能在for循环中通过修改下标值的方式迫使它提前结束循环。如果有需要提前结束循环，那么应该使用while循环。用wile(true)表示无限循环。在迭代数组或者容器中的元素时，我们应该优先选择for each 循环。

### **循环入口**

在进入循环的时候，我们应该要明确只有一个位置能进入循环。而且初始化代码应该放在循环体之前。

### **循环体**

在循环中我们尽量保证该循环只完成一个明确的任务，尽可能减少循环嵌套的层数。

### **循环出口**

除了无限循环在写循环出口时，我们应该能保证循环能够终止，尽可能让循环终止条件变得明显。并且要尽可能减少循环的出口处。避免在循环退出之后还要使用循环下标的情况。

## **高质量子程序设计**

**创建子程序的优点**

-   **避免代码重复，提高可移植性。**创建子程序最普遍的一个原因就是避免重复的代码，我们应该将重复的代码装进同一个子程序中，然后在需要使用重复代码的地方调用子程序。
-   **降低复杂度**。降低程序复杂度也是创建子程序重要的原因，如果程序中有些比较复杂的代码，那么创建一个子程序，并为该子程序取一个合适的名字，在使用子程序时就无需了解内部的工作细节。如果我们直接使用一些复杂的语句，更容易出错。但是将复杂的语句隔离在子程序内部，我们能够将精力集中在子程序完成的功能上而非细节。
-   **改善性能**。通过使用子程序，我们只需要在一个地方优化代码。在一处优化的同时，使用该子程序的地方都能受益。

**设计子程序名**

通过设计一个好的子程序名，能够是我们即使不观察内部代码，也能清楚知道该程序完成的所有功能。以下是给子程序取名的指导性原则。

-   **子程序名能够描述子程序完成的所有功能**。子程序的名字应当要描述所有的输出结果**以及其副作用**。如果一个子程序的作用是计算报表总额并且打开一个输出文件，那么取名为computeReportTotals()还不算完整，computeReportTotalsAndOpenOutputFile() 才算完整。但是这样显得程序名过长，要完成这一点，也要求我们在设计子程序的时候，尽量让子程序只完成一个功能，而且该功能不能与其他子程序功能重叠，否则就要考虑自己的子程序是否需要重新设计。
-   **避免使用无意义、模糊不清的动词**。有些动词过于灵活，以至于放在程序名中并不能很准确地描述程序功能，显得有些模棱两可。比如说，HandleOutput()、DealWithOutput()。这些程序名其实没有说明是如何处理输出的，handle、deal这个词放在这里并没有太多的明确信息。如果取名为FormatAndPrintOutput()，那么我们无需观察内部代码也能知道该子程序的任务了。
-   **不能仅仅在子程序名中加数字后缀区分不同程序**。我以前也会仅仅添加数字后缀来取不同的程序名，但造成的结果是，一段时间之后，我自己都弄不清楚不同“版本”程序之间的别。
-   **子程序名合适的长度**。《代码大全》给出研究表明，子程序名合适的长度在9到15之间。当然实际情况，还是得看子程序名是否足够准确描述了其子程序功能。
-   **如果子程序有返回值，那么最好在子程序名上体现出来**。
-   **子程序名应该是动词加宾语的形式**。一个具有高内聚的子程序，应该是针对某一对象执行的一种操作。

### **高内聚低耦合**

子程序应该有着高内聚低耦合的特征。

内聚性是指程序里各种操作间的紧密程度，”内聚性“和“强度”一词有着异曲同工之妙。举个例子，Cosine()（余弦函数）就是极度内聚的、强度极大的一个函数，因为这个函数只完成一个操作，就是求余弦值。而CosineAndTan()(余弦与正切)的内聚性或者说强度就不如前者，因为它做了两个操作，除了求余弦之外，还求了正切值。高内聚原则就是尽可能让一个子程序只完成一个操作。之所以要做到尽可能的高内聚是因为，假设另一个子程序需要用到余弦值，那么直接调用Cosine()即可，但如果我们只有CosineAndTan()，在调用该子程序的同时还需要对结果做额外的处理。

耦合可以看作是，各个子程序之间，或者说是各个模块之间的紧密程度，不同子程序或者模块之间联系越紧密，则耦合性越高，子程序和模块的独立性就越差，灵活度更低。假设耦合度非常高，各个子程序之间相互强相关，如果一个项目中有20个子程序，有可能仅仅是因为要修改其中一个子程序，结果导致其他19个子程序也需要修改。

### **子程序参数**

因为各个子程序之间要尽可能做到只通过参数来进行通信，所以子程序的参数尤为重要。而且《代码大全》表明子程序之间的接口是程序最易出错的部分之一。以下是对子程序参数设计和使用的一些指导原则总结。

-   **按照输入-修改-输出的顺序排列参数**。这种排列方式与子程序内部操作的顺序一致，使用时也会尽可能地减少遗漏参数、弄错排列顺序的可能性。
-   **如果几个子程序都使用到了类似的参数，那么应该让这些参数的片列顺序保持一致**。保持一致性能够产生记忆效应，也能降低错误率。
-   **对参数进行说明**。在确定好子程序的参数时，就应该对参数进行详细的说明，无论是指导自己完成子程序的剩余工作，还是方便日后使用该子程序都有极大的帮助。
-   **把子程序的参数限制在大约7个以内**。限定参数个数，也是降低代码复杂度的一种方式。如果发现自己编写子程序时，传递的参数一直都很多。那么可以检查下是否是子程序之间的耦合度过高，联系过于紧密。如果是的话，那么就要想办法降低子程序之间的耦合度。合理的办法有，将这些子程序写进一个大类中，将他们共同使用的参数作为类的成员变量。
-   **使用具名参数**。在某些支持具名参数的编程语言中，使用具名参数能够有效降低调用子程序时的错误率。也能提高代码的可读性。
  
  