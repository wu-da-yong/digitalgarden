---
{"dg-publish":true,"permalink":"/Zettelkasten/14e2c C语言程序设计/","dgPassFrontmatter":true}
---

编号:: 14e2c
标题:: C语言程序设计
创建时间:: 2023-07-19 04:52
up:: [[Zettelkasten/14e2 编程的本质是对现实建模\|14e2 编程的本质是对现实建模]]
来源:: 

---

- 变量与常量
    - 常量
        - 符号常量
            - `#define`指令可以把符号名字（或称为符号常量）定义为一特定的字符串：``#define`` 名字 替换文本（比如‘23’，‘x’）
        - 字符常量
            - 写成用单引号括住单个字符的的形式。如'x'
            - 字符常量的值是该字符在**机器字符集**中的数值。
            - 虽然字符常量一般用来与其他字符进行比较，但字符常量也可以像整数一样参与数值运算。
            - 八进制的‘1’用'\001'表示，十六进制的‘1’用‘\x01’表示
            - 换码序列
                - ![attachment/Pasted image 20220424214440.png](/img/user/attachment/Pasted%20image%2020220424214440.png)
        - 常量表达式
            - 常量表达式是其中只涉及到常量的表达式。
            - 这种表达式可以在编译时计算而不必推迟到运行时，因而可以用在常量可以出现的任何位置。
        - 字符串常量
            - 双引号不是字符串的一部分，它只用于限定字符串。
            - 从技术角度看，字符串常量就是字符数组。在内部表示字符串时要用一个空字符 "\0'来结尾。 故用于存储字符串的物理存储单元数比括在双引号中的字符数多一个
        - 枚举常量
            - 是一个常量整数值的列表
            - 在enum说明中第一个枚举名的值为0，第二个为1、如此等等。如果第一个枚举名不为0，则后续枚举名的值在第一个的值的基础上累加1。
        - 整数常量
            - long常量以l或L结尾
            - 无符号常量用u或U结尾
            - 整数常量除了用十进制表示外，还可以用八进制（第一个数字为0）或十六进制（第一个数字为0x）表示。
        - 浮点数常量
            - 浮点常量中必须包含一个小数点（如123.4）或指数（如1e-2）或两者都包含
            - 在没有后缀时类型为double。后缀f与F用于指定float常量
    - 变量
        - 变量名
            - 变量名不能用关键字
                - 诸如if、else、int、float等关键词是保留的，不能把它们用做变量名。所有关 键词中的字符都必须小写。
            - 变量名不以下划线开头
                - 因为库函数通常使用以下划线开头的名字。
            - 外部变量的命名更严格
        - 变量或函数的声明
            - 重要性
                - **除了某些可以通过上下文做的隐式说明外，所有变量都必须先声明才能使用**。
            - 使用方法
                - 同一类型的变量可以以任何方式分散在多个说明中
                - 变量在说明时可以同时初始化
            - [[Zettelkasten/14e2c C语言程序设计#自动变量\|#自动变量]]与非自动变量的说明
                - 非自动变量只初始化一次，一般在程序开始执行之前进行，此时初始化符必须为常量表达式
                - 显式初始化的自动变量每当进入其所在的函数或分程序时就进行一次初始化，其初始化符可以是任何表达式。
                - 外部变量与静态变量的缺省初值为0。
                - 未经显式初始化的自动变量的值为未定义值（即为垃圾）。
            - const限定符
                - 该限定符用于指定该变量的值不能改变，对于数组， const限定符使数组所有元素的值都不能改变
        - 变量的分类
            - 标准变量
            - 数组变量
                - **数组名是该数组首元素的地址**
                - 声明
                    - 普通声明
                    - 只读声明
                        - const int days[12]
                - 初始化
                    - 限定元素个数的初始化
                    - 不限定元素个数的初始化
                    - 指定初始化器
                        - int arr[6] = {[5] = 212};  这里把arr[5]初始化为212，未初始化的元素置为0。
                - 赋值
                    - 只能给数组元素赋值，不能给整个数组赋值（但可以通过初始化的方式变相赋值）
            - 指针变量
        - 变量的类型
            - 基本类型
                - char   单字节、可以存放字符集中一个字符。 
                - int  整数，一般反映了宿主机上整数的自然大小。 
                - float 单精度浮点数。 
                - double 双精度浮点数。 
            - 限定基本类型的限定符
                - long，short，longlong
                    - 只用来限定int
                    - 现在，个人计算机上最常见的设置是，longlong占64位，long占32位，short占16位，int占16位或32位（依计算机的**自然字长**而定）。原则上，这4种类型代表4种不同的大小，但是在实际使用中，有些类型之间通常有重叠。
                - signed和unsigned
                    - 用于限定char类型或任何整数类型（long int，int等等）
                    - 如果char对象占用8位，那么unsigned char变量的取值范围为0~255，而signed char变量的取值范围则为-128~127 （在采用补码的机器上）
- 运算符与表达式
    - 算数运算符
        - 二元算术运算符包括：%（取模运算符）、+、-、/、*
            - 取模运算符%不能作用于float或double对象
            - 在有负的运算分量时，整数除法截取的方向以及 飞散 取模运算结果的符号取决于具体机器，在出现上溢或下溢时所要采取的动作也取决于具体机器。
        - 一元运算符有："delete"、”sizeof"、“void”、'+'（正号），'-'（负号），'!'， '++'， '--' ， '~'（位非）
    - 关系运算符
        - 包括：>   >=    <    <=
        - 优先级正好比它们低一级的是等于运算符：==    !=
        - 关系运算符的优先级比算数运算符低
    - 加一与减一运算符
        - 含义
            - 加一运算符++用于使其运算分量加1， 减一运算符--用于使其运算分量减1。
        - 前缀和后缀的区别
            - ++n 指的是在n的值被使用之前先使n加1
            - n++ 指的是在n的值被使用之后再使n加1
        - 只能作用与变量，不能作用于表达式
    - 按位运算符
        - 作用对象
            - 语言提供了六个用于位操作的运算符（| & ^ << >> ~ ），这些运算符只能作用于整数分量
        - 用途
            - 按位与运算符& 经常用于屏蔽某些位，也用于取变量的地址
            - 按位或运算符| 用于打开某些位。
            - 位异或运算符^用干在其两个运算分量的对应位不相同时置该位为1，否则，置该位为0。
            - 移位运算符<<与>>分别用于将左运算分量左移与右移由右运算分量所指定的位数（右运算 分量的值必须是正的）
            - 一元运算符~用于求整数的反码，即它分别将运算分量各位上的1转换成0，0转换成1
    - 赋值运算符与赋值表达式
        - 简单赋值运算符 ：=
        - 复合赋值运算符：+=、-=、*=、/=、%= 、>>=、<<=、&=、^=与!=）
            - 等价规则
                - 以+=为例，表达式1 += 表达式2 等价于 表达式1=（表达式1）+（表达式2）
            - 在所有这类表达式中，赋值表达式的类型就是左运算分量的类型，值也是在赋值后左运算分量的值。
    - 条件表达式
        - 形如z ={a > b)? a:b; / * Z = max(a,b)*/
        - 件运算符 ?∶的优先级非常低，仅高于赋值运算符
    - **类型转换**
        - 由于char类型就是小整数类型，在算术表达式中可以自由地使用char类型的变量或常量。这 就使得在某些字符转换中有了很大的灵活性。
            - 例子
                - 这是数字字符串转换成对应的数值的函数![attachment/Pasted image 20220424224519.png](/img/user/attachment/Pasted%20image%2020220424224519.png) ``s[i] - ‘0’`` 用于求`s[i]`中存储的字符所对应的数字值，因为'0'、'1'、'2'等的值形成了一个连续的递增序列。
        - 标准头文件<ctype.h>定义了一组用于进行独立于字符集的测试和转换的函数。
        - 把一个char类型的值转换成int类型的值时,结果的正负是未知的
            - 在某些机器上，如果字符的最左一位为1，那 么就被转换成负整数（称做"符号扩展"）。
            - 在另一些机器上，采取的是提升的方法。通过在最 左边加上0把字符提升为整数，这样转换的结果总是正的。
            - 原因
                - C语言没有指定char类型变量是无符号量还是有符号量。
            - 意义
                - 为了保证程序的可移植性，如果要在char变量中存储非字符数据，那么最好指定signed或 unsigned限定符。
        - **无符号类型时的运算转换**
            - 如果某个运算分量的类型为long double，那么将另一个运算分量也转换成long double类型; 
            - 如果某个运算分量的类型为double，那么将另一个运算分量也转换成double类型; 
            - 如果某个运算分量的类型为float，那么将另一个运算分量也转换成float类型; 
            - 将char与short类型的运算分量转换成int类型。 
            - 如果某个运算分量的类型为long，那么将另一个运算分量也转换成long类型。
        - **有符号类型时的运算转换**
            - 主要问题
                - 有符号值与无符号值之间的比较运算取决于机器，因为它们取决于各个整数类型的大小，这导致转换规则复杂
            - 假定 int对象占16位，long对象占32位，那么，~1L<1U，这是因为int类型的-1U被提升为signed long 类型;但-1L>1UL，这是因为-1L被提升为unsignedlong类型，因此它是一个比较大的正数。
        - 在进行赋值时也要进行类型转换，= 右边的值要转换成左边变量的类型
        - 变量传递给函数时也可能引起类型转换
            - 在没有函数原型的情况下。char与short类型转换成int类型。float类型转换成double类型
        - 强制转换
            - 形式为（类型名）表达式，例如sqrt((double)n)
            - 强制转换的精确含义是，表达式首先被赋给类型名指定类型的某个变量，然后再将其用在整个构造所在的位置。
    - **运算符优先级与表达式求值次序**
        - 优先度表格
            - ![attachment/Pasted image 20220425175438.png](/img/user/attachment/Pasted%20image%2020220425175438.png)
        - C语言没有指定同一运算符的几个运算分量的计算次序（&&、!、?∶ 与，除外）。例如，在 X:F()+g（)；中，f（）可以在g（）之前计算，也可以在g（）之后计算。为了保证 特定的计算次序，可以把中间结果保存到临时变量中。
- 控制流
    - 主要作用
        - 控制流语句用于指定各个计算执行的次序
    - 语句与复合语句
        - 在诸如x=0、i++或printf ⋯）之类的表达式之后加上一个分号（;），就使它们变成语句
        - 可以用一对花括号{与把一组说明和语句括在一起构成一个复合语句（也叫分程序），复合语句在语法上等价于单个语句。在用于终止分程序的右花括号之后不能有分号。
    - if-else语句
        - if-else语句用于表示判定。
        - 语法形式
            - ![attachment/Pasted image 20220425182359.png](/img/user/attachment/Pasted%20image%2020220425182359.png)
        - 建议在if语句嵌套的情况下尽可能使用 花括号。
    - else-if语句
        - 是编写多路判定的最一般的方法。
        - 语法形态
            - ![attachment/Pasted image 20220425182453.png](/img/user/attachment/Pasted%20image%2020220425182453.png)
            - 各个表达式依次求值。一但某个表达式为真，那么就执行与之相关的 语句。从而终止整个语句序列的执行
            - 最后一个else部分用于处理"上述条件均不成立"的情况或缺省情况，可以省略，也可以用来检查错误（捕捉不可能的条件）
    - switch语句
        - 是一种多路判定语句。它根据表达式是否与若干常量整数值中的某一个匹配来相应地执行有关的分支动作
        - 语法形态
            - ![attachment/Pasted image 20220425191152.png](/img/user/attachment/Pasted%20image%2020220425191152.png)
            - 每一种情形都由一个或多个整数值常量或常量表达式标记。如果某一种情形与表达式的值匹配， 那么就从这个情形开始执行。
            - 在 某个case情形之后的代码执行完后，就进入下一个case情形执行，除非显式控制转出。转出 switch语最常用的方法是使用break语句与return语句。
            - 如果没有一个情形能满足。那 么执行标记为default的情形。
            - 如果没有default情形并肖没有--个情形与表 达式的值匹配，那么该switch语句不执行任何动作。
    - while与for循环语句
        - while语句
            - while循环语句的执行步骤如下：首先测试圆括号中的条件。如果条件为真，则执行循环体（一般是括在花括号中的数个个语句）
        - for语句
            - 圆括号中由三个部分，第一部分初始值，第二部分条件判断，结果为真则继续执行第三部分。
            - 在for循环语句中经常要使用到逗号运算符“，”。由逗号分隔的各个表达式从左至右进行求值，结果的类型和值是右运算分量的类型和值。（用于分隔函数变元、说明中的变量等的逗号不是逗号运算符）
            - 请谨慎使用运算符“，”
    - do-while循环语句
        - 与while和 for的区别
            - do-while在循环体执行完后再测试终止条件
        - 语法形态
            - ![attachment/Pasted image 20220425193237.png](/img/user/attachment/Pasted%20image%2020220425193237.png)
            - 在do-white循环语句执行时。先要执行语句。然后再求表达式的值。如果表达式的值为直.那么 就再次执行语句
    - break语句与continue语句
        - reak语句可用于从switch、for、while与do-while语句中提前退出来
        - continue语句用于使其所在的for、while或dowhile语句开始下一次循环
        - 在while与do-whilc语句中，continue语句的执行意味着立即执行测试 部分;在for循环语句中，continue语句的执行则意味着使控制传递到增量部分。
        - continue语句只 能用于循环语句，不能用于switch语句。
    - goto语句与标号
        - C语言提供了可以毫无节制使用的goto语句以及标记goto语句所要转向的位置的标号
        - 最常见的用法是在某些深度嵌套的结构中 放弃处理，例如一次中止两层或多层循环。
        - 标号的形式与变量名字相同，其后要跟—个冒号。标号可以用在任何语句的前面，但要与相应的goto语句位于同一函数中。（标号作用域为整个函数）
- 函数与程序结构
    - 头文件
        - 把定义和声明放在头文件中，实现它们在多个源文件中的共享。
        - C预处理程序
            - 含义
                - 从概念上讲，预处理器是编译过程中单独执行的第一个步骤
            - 分类
                - 文件包含，inclede使得处理大量的`#define` 指令以及声明更加方便
                - 宏替换，形如：#define 名字 替换文本
                - 条件包含，用于在预处理中进行条件控制。这提供了一种在编译 过程中可以根据所求条件的值有选择地包含不同代码的手段。
    - 函数的基本知识
        - 用途
            - 函数用于把较大的计算任务分解成若干个较小的任务。
        - 函数声明与定义
            - 函数声明
                - 函数声明（又称函数原型）只与函数定义的第一行相同。声明可以不写形参名，只写形参类型。
            - 函数定义
                - ![attachment/Pasted image 20220425203556.png](/img/user/attachment/Pasted%20image%2020220425203556.png)
                - 函数定义的各个部分都可以缺省，如 dumnay ( ){}，这个函数什么也不做、什么也不返回，它可以在程序开发期间用做占位符。
            - 被调用函数的三种情况
                - 被调用函数的定义在主调函数前，可以不加声明
                - 被调用函数的定义在主调函数之后，可以先给出声明
                - 被调用函数的声明在主调函数后，编译系统将第一次遇到的函数形式（即函数名 （实参列表））作为函数声明
        - 函数的概念
            - 程序是函数定义与变量定义的集合，因此一个C程序可以分为若干个函数
            - 不同函数的定义可以以任意次序出现在一个源文件或多个源文件中，但同一函数不能分开存放在几个文件中。
            - 每个程序有且只能有一个主函数（main），其他函数都是“子函数”
            - 子函数可以互相调用，但主函数不能被调用
            - **c程序的执行从main函数开始，调用其他函数后人回到main函数，程序在main函数结束时结束**
        - 函数之间的通信可以通过变元、函数返回值以及外部变量进行。
            - 函数调用形式
                - 函数名 （实参列表）
        - **实参与形参**
            - 形式参数是被调函数中的变量，实际参数是主调函数赋给被调函数的具体值。实际参数可以是常量、变量，或甚至是更复杂的表达式。无论实际参数是何种形式都要被求值，然后该值被拷贝给被调函数相应的形式参数。
        - 返回值
            - return语句用于从被调用函数向调用者返回值，return之后可以跟任何表达式。
            - 返回值返回到主调函数。在主调函数中，可以把返回值赋给另一个变量、作为表达式中的值、作为另一个函数的参数。
            - 调用函数可以随意忽略掉返回值。
            - 被调用函数的声明与定义必须一致
                - 如果被调用函数与主调函数在一个源文件里，并且具有不一致的类型，那么编译程序将会检测出这个错误。
                - 如果被调用函数与主调函数不在一个源文件里，并且具有不一致的类型，那么这种不匹配的错误就不会被检测出来。数据类型的不一致将导致结果毫无意义。
                - 函数的声明与定义必须一致的一般原因
                    - 如果没有函数原型，则函数将在第一次出现的表达式中被隐式声明。
                        - 如果在前面已经说明过的某个名字出现在某个表达式中并且左边跟一个左圆括号，那么就根据上下文认为该名字是函数名学。该函数的返回值类型为int。但上下文不对其参数做任何假设，即使（）为空。
                        - 所以，推荐的编程风格是如果一个函数有变元、那么说明它们;如果没有变元，那么使用void。
    - 变量的作用域
        - 分为内部和外部
            - 内部变量（局部变量）
                - 三种形式
                    - 在一个函数内部定义的变量
                    - 函数的形式参数
                    - 在某个复合语句中定义的变量
            - 外部变量（全局变量）
                - 普遍性
                    - C语言可以看成由一系列外部对象构成，这些外部对象可能是变量或函数。由于C语言不允许在一个函数中定义其他函数，因此函数本身也是“外部的”。
                - **性质**
                    - 外部变量定义在函数之外
                    - 全局范围内都可访问（跨源文件使用需通过extern）。通过同一个名字对外部变量的所有引用（即使这种引用来自于单独编译的不同函数）实际上都是引用同一个对象（标准中把这一性质称为外部链接）。
                - 作用
                    - 是函数之间数据交换的一种方式，可以替代函数参数与返回值的方式。
                    - 具有比内部变量（局部变量）更大的作用域和更长的生存期
                        - 如果两个函数必须共享某些数据，而这两个函数都互不调用对方，那么最为方便的是，把这些共享数据作成外部变量，而不是作为函数参数来传递。
                - 初始化
                    - 只能出现在定义性声明中
        - 作用域规则
            - 含义
                - 变量的作用域指的是程序中可以使用改变量的部分
            - 不同对象的不同作用域
                - 对于某函数的参数和其**自动变量**来说，他们的定义域就在该函数内
                - 对于外部变量或函数来说，作用域从声明他的地方开始，到其所在的（待编译的）文件末尾为止。
    - 变量的存储类型（生存期）
        - 分为静态和动态
            - 静态变量：从程序开始执行到程序结束
            - 动态变量：从包含该变量定义的函数开始执行至函数执行结束
        - 内存中供用户使用的存储空间包括：
            - 【1】程序区
            - 【2】静态存储区：程序运行期间（编译时）分配固定的存储空间。
            - 【3】动态存储区：程序运行期间（执行时）根据需要动态分配存储空间。
        - 局部变量的存储类型
            - 局部自动变量 
                - 用auto声明，可省略。
                - 函数内部无static声明的局部变量均为动态存储类别。
                - 自动变量被分配在动态区，未赋初值时，其值未定义，每次调用重新赋值。
            - 局部静态型 
                - 用static声明
                - 局部静态变量属于静态存储类别。在程序整个运行期间都不释放存储空间，程序运行结束后才释放存储单元。
                - 局部静态变量在编译时赋初值（仅赋一次值），前次结果保留。
                - 如果局部动态变量若未赋初值，其值不确定；局部静态变量时没有赋初值，编译时会自动赋初值，其值为0或‘\0’(字符变量)。
                - 局部静态变量只能在定义它的函数内被引用（调用结束后存在但不能被其他函数使用）。
            - 寄存器型 register
                - 用register声明告诉编译器，它所声明的变量在程序中使用频率较高。其思想是，将register 变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以忽略此选项
                - 寄存器说明只适用于自动变量以及函数的形式参数。
                - 寄存器变量对寄存器的占用是动态的，存放位置是寄存器。
        - 全局变量的存储类型（全局变量都是静态的）
            - 用 extern 说明一个在其他原文件中定义的全局变量
            - 用 static 说明一个不能在其他原文件中定义引用的全局变量
    - 变量按照作用域与生存期的划分
        - ![attachment/Pasted image 20220428031517.png](/img/user/attachment/Pasted%20image%2020220428031517.png)
    - **extern声明**
        - 使用场景
            - 如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字 extern。
        - 与定义性声明的区别
            - extern声明只说明变量的属性（主要是类型），而定义性声明除此之外还将引起存储器的分配。
            - extern声明不一定要指定数组的长度，而定义中必须指定数组的长度。
        - 性质
            - 一个外部变量只能在文件中定义一次，而其他文件可以通过extern声明来访问它。
    - **static声明**
        - 使用场景
            - **使得外部变量仅供其所在的源文件中的函数使用，其他函数不能访问。此时被成为静态变量**。
            - 也可用于声明函数，使得该书含名除了对该函数声明用ozldewfjm可见外，其他文件无法访问。
    - 复合语句结构
        - 可以在复合语句中定义（包括初始化）变量，使用方式为紧跟在任何其他表示符合语句开始的做花括号之后。
        - 这种方式声明的变量可以隐藏在复合语句外与之同名的变量。
    - 初始化
        - 在不进行显式初始化的情况下，外部变量和静态变量都为0，自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）。
        - 对于标量变量，数组变量和字符数组的初始化各有不同
            - 标量变量，其初始化形如int X= 1;
                - 对于外部变量与静态变量，初始化符必须是常量表达式，初始化只做-一次（从概念上讲是 在程序开始执行前进行初始化）。
                - 对于自动变量与寄存器变量来说，每当进入函数或复合函数时进行初始化。他们的初始化符不一定限定为常量∶它可以是任何表达式，其中可 以包含前面已定义过的值甚至可以包含函数调用。
            - 数组变量：数组初始化符是用花括号括住并用逗号分隔的初始化符序列。
                - 如果初始化符序列中初始化符的个数比数组元素数少，那么对干没有得到初始化的数组元 素在该数组为外部变量、静态变量与自动变量时被初始化为0。
                - 如果初始化符序列中初始化符的 个数比数组元素数多，那么就是错误的。
            - 字符数组（C语言没有专门用于储存字符串的变量类型，字符串都被储存在char类 型的数组中）
                - 可以用一个字符串来代替用花括号括住并用逗号分隔的初始化符序列
    - 函数递归
        - 定义
            - 递归调用，函数可以直接或间接调用自身。
        - 特点
            - 递归并不节省存储器的开销，因为递归调用过程中必须在某个地方维护一个存储处理值的栈。递归的执行速度并不快，但递归代码比较紧凑，并且比相应的非递归代码更易于编写与理解。
- 指针与数组
    - 指针基本概念
        - 指针的声明
            - 形如 ``int *P;``
        - 运算符
            - 用于取一个对象的地址，地址运算符&只能应用于内存中的对象，即变量与数组元素。它不能作用于表达式、常量或 register类型的变量。形如ptr = &pooh; // 把pooh的地址赋给ptr
            - 间接寻址运算符`*`用于取出指针内存储的地址
        - 用途
            - 可以是主调函数将指向所要交换的变量的指针传递给被调用函数，以实现被调用函数访问并修改主调函数中对象的值。
        - 关于机器地址
            - 指针是一种用于存放另一个变量的地址的变量（地址通常为2或4个字节长）
            - 在机器的内存中，一个字长可以存放char类型的数据，两个相邻的字节可以存放一个short类型的数据，4个可以存放一个long类型数据。
        - 每个指针都必须指向某种特定的数据类型。（一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身）。
    - 地址算术运算
        - 有效的指针运算只有四种：
            - 相同类型指针之间的赋值运算;
            - 指针值加或减一个整数值的运算; 
                - 在计算p+n 时，n将根据p指向的对象的长度按比例缩放，而p指向的对象的长度则取决于 p 的声明。例如，如果 int 类型占 4 个字节的存储空间，那么在 int 类型的计算中，对应的 n 将按 4 的倍数来计算。
            - 指向相同数组中的元素的指针之间的减或比较运算;
            - 将指针赋0或指针与0之间的比较运算。
        - 初始化
            - 有意义的初始化值是0或表示地址的表达式（表达式所代表的地址必须是此前已经定义的具有适当类型的数据的地址）
        - 运算的一致性
            - 如果处理的数据类型是比字符型占据更多存储空间的浮点类型，并且 p 是一个指向浮点类型的指针，那么在执行 p++后，p 将指向下一个浮点数的地址。
    - 指针与数组
        - 数组传递
            - 当把数组名传递给一个函数时，实际上传递的是该数组第一个元索的地址。**因此数组名参数必须是一个指针**，也就是一个存储地址值的变量。
        - 差异
            - 指针是一个变量，因此，在 C语言中，语句pa--和pa++都是合法的。但数组名不是变量，因此，类似于a--和a++形式的语句是非法的。
    - 指针与字符串常量
        - 字符串常量作为函数参数被使用时
            - 在`printf ("hello,world\n");` 中，实际上是通过字符指针访问它的，函数printf接收的是一个指向字符数组的头一个字符的指针
        - 给数组和指针赋值
            - `char amessage[]="now is the time";/* 定义一个数组 */    char *pmessage="now is the time"; /* 定义一个指针*/ ` 
            - 数组的单个字符可以修改，始终在同一个存储位置。
            - 指针无法修改字符串，可以被修改到其他地址。
    - 多维数组
        - 表示方法
            - `daytab[i][j]
        - 存储方式
            - 数组存储按行存储
        - 初始化
            - 用花括号括起来的初值表进行初始化，二维数组的每一行由相应的子列表进行初始化。
        - 函数调用多维数组时传递的是指针，它指向每一行的首个元素。
    - 命令行参数
        - argc和argv[]
    - 指向函数的指针
        - 
    - 复杂说明
        - 
- 结构
    - 基本知识
        - 本质
            - 结构由两层含义：一层是“结构布局”，一层是创建一个结构变量。从本质上看， xxx结构声明创建了一个名为struct xxx的新类型。
        - 两种声明方式（struct xxx{}；）
            - 声明结构的过程和定义结构变量的过程可以组合成一个步骤（上文的xxx可忽略）。
            - 在一处声明结构布局，在另一处定义实际的结构变量。此时必须使用结构标记（即上文的xxx）。
        - 结构成员
            - 在结构声明中，用一对花括号括起来的是结构成员列表
            - 右花括号后面的分号是声明所必需的，表示结构布局定义结束
        - 初始化
            - 如果初始化一个静态存储期的结构，初始化列表中的值必须是常量表达式。如果是自动存储期，初始化列表中的值可以不是常量。
        - 结构的合法操作
            - 访问其成员
            - 作为一个整体复制和赋值
            - 通过&运算符取地址
    - 结构数组
        - 声明方式
            - struct book library[MAXBKS]; 以上代码把library声明为一个内含MAXBKS个元素的数组。数组的每个元素都是一个book类型的结构。
        - 结构数组成员
            - library[0].value
    - 结构指针
        - 表示方法
            - `struct point*pp;`  将pp定义为指向struct point类型对象的指针，pp可以指向任意现有的point类型的结构
        - 取值
            - 指向变量
                - pp=&变量名
            - 访问成员
                - 如果him是指向guy类型结构barney的指针，下面的关系恒成立： `barney.income == (*him).income == him->income`  括号是必需的，因为结构成员运算符“.”的优先级更高
    - 类型定义（typedef）
        - 形如typedef int Length，typedef定义的类型名首字母要大写（Length）
        - 可用于类型声明，类型转换
        - 在语法上类似于存储类extern、static
        - typedef 声明没有创建新的类型，也没有增加任何新的语义：通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性。
    - 联合（union）
        - 联合一次只能储存一个值，这与结构不同。
        - 创建联合的方法
            - 和创建结构的方式相同，需要一个联合模板和联合变量。可以 用一个步骤定义联合，也可以用联合标记分两步定义
        - 访问成员
            - `联合名.成员`或 `联合指针->成员`
        - 本质
            - 实际上，联合就是一个结构，它的所有成员相对于基地址的偏移量都为0，此结构空间要大到足够容纳最“宽”的成员，并且，其对齐方式要适合于联合中所有类型的成员。对联合允许的操作与对结构允许的操作相同：作为一个整体单元进行赋值、复制、取地址及访问其中一个成员。
        - 有 3 种初始化的方法：
            - 把一个联合初始化为另一个同类型的联合；
            - 初始 化联合的第1个元素；
            - 或者根据C99标准，使用指定初始化器。
    - 位字段
        - 定义方式
            - 位字段通过一个结构声明来建立，该结构声明为每个字段提供标签， 并确定该字段的宽度
            - ![attachment/Pasted image 20220426215750.png](/img/user/attachment/Pasted%20image%2020220426215750.png)
        - 用途
            - 可以通过普通的结构成员 运算符（.）单独给这些字段赋值，但要确保所赋的值不超出字段可容纳的范围。
        - 不容易移植
            - 字段储存在一个int中的顺序取决于机器。在有些机器上，存储的顺序是 从左往右，而在另一些机器上，是从右往左
            - 不同的机器中两个字段 边界的位置也有区别
- 输入与输出
    - 标准输入输出
        - 标准输入一般为键盘，标准输出一般为显示器
        - 常用函数
            - getchar（）每次调用时返回下一个输入字符，putchar（）每次调用时返回下一个输出字符
        - 输入重定向（<）
            - 形如：程序名<输入文件名 ，将把程序的输入从键盘输入替换为文件输入
        - 输出重定向（>）
            - 形如：程序名>输出文件名，将把程序的输出从标准输出重定向到文件中
        - 管道重定向
            - 形如 程序1|程序2，将把程序1的输出中2标准输出通过管道重定向到程序2的标准输入中
    - 格式化输出——printf函数
        - 用途
            - 函数printf在输出格式format的控制下，将其参数进行转换与格式化，并在标准输出设备上打印出来。它的返回值为打印的字符数。
        - 转换说明（由%+修饰符+转换字符组成）
            - 功能
                - 它们指定了如何把数据转换成可显示的形式
            - 转换说明
                - %a 浮点数、十六进制数和 p 记数法（C99/C11）
                - %A 浮点数、十六进制数和 p记数法（C99/C11）
                - %c 单个字符
                - %d 有符号十进制整数
                - %e 浮点数，e记数法
                - %E 浮点数，e 记数法
                - %f 浮点数，十进制记数法
                - %g 根据值的不同，自动选择%f或%e。%e 格式用于指数小于-4 或者大于或等于精度时
                - %G 根据值的不同，自动选择%f或%E。%E 格式用于指数小于-4 或者大于或等于精度时
                - %i 有符号十进制整数（与%d相同）
                - %o 无符号八进制整数
                - %p 指针
                - %s 字符串
                - %u 无符号十进制整数
                - %x 无符号十六进制整数，使用十六进制数 0f
                - %X 无符号十六进制整数，使用十六进制数 0F
                - ``%%`` 打印一个百分号
            - 修饰符
                - 功能
                    - 在%和转换字符之间插入修饰符可修饰基本的转换说明
                - 常用修饰符
                    - 标记（-、+、空格、#和0），可以使用多个标记
                        - - 待打印项左对齐
                        - + 显示有符号值的正负符号
                        - 空格 有符号值为正，则在值前面现实签到空格（不显示任何符号）；若为负，则在值前面显示减号+标记覆盖一个空格
                        - （#）把结果转换成另一个形式
                            - 对于%o 格式，则以 0 开始
                            - 对于%x或%X格式，则以 0x 或 0X 开始
                            - 对于所有的浮点格式，#保证了即使后面没有任何数字，也打印一个小数点字符
                            - 对于% 和%G 格式，#防止结果后面的 0 被删除
                        - 0 对于数值格式，用前导0代替空格填充字段宽度。对于整数格式，如果出现-标记或指定精度，则忽略该标记
                    - 数字 最小字段宽度
                    - .数字 表明精度。
                        - 对于%e、%E和%f转换,表示小数点右边数字的位数；
                        - 对于%g和%G转换，表示有效数字最大位数；
                        - 对于%s转换，表示待打印字符的最大数量；
                        - 对于整型转换,表示待打印数字的最小位数。
                    - `%*d`，那么参数列表中应包含`*`和 d对应的值。
                    - h 和整型转换说明一起使用，表示 short int或unsigned short int 类型的值，示例："%hu"、"%hx"、"%6.4hd"
                    - hh 和整型转换说明一起使用，表示 signed char或unsigned char 类型的值，示例："%hhu"、"%hhx"、"%6.4hhd"
                    - j 和整型转换说明一起使用，表示 intmax_t或uintmax t 类型的值。这些类型定义在 stdint.h 中，示例："%jd"、"%8jx"
                    - l 和整型转换说明一起使用，表示 long int或unsigned long int 类型的值，示例："8ld"、"%8lu"
                    - ll 和整型转换说明一起使用，表示 long long int或unsigned long long int类型的值（C99），示例："%lld"、"%8llu"
                    - L 和浮点转换说明一起使用，表示 long double 类型的值，示例："%Ld"、"810.4Le"
                    - t 和整型转换说明一起使用，表示ptrdiff_t类型的值。ptrdiff_t 是两个指针差值的类型（C99），示例："%td"、"%12ti"
                    - z 和整型转换说明一起使用，表示 size_t 类型的值。size_t 是 sizeof返回的类型（C99），示例："%zd"、"%12zd"
    - 格式化输入——scanf函数
        - 形式
            - ![attachment/Pasted image 20220427214137.png](/img/user/attachment/Pasted%20image%2020220427214137.png)
        - 用途
            - 函数scanf 从标准输入中读取字符序列，按照 format 中的格式说明对字符序列进行解释，并把结果保存到其余的参数中。调动的变量必须为指针。
        - 转换说明（由%+修饰符+转换字符组成）
            - %c把输入解释成字符
            - %d把输入解释成有符号十进制整数
            - %e、%f、%g、%a把输入解释成浮点数（C99标准新增了%a）
            - %E、%F、%G、%A把输入解释成浮点数（C99标准新增了%A）
            - %i把输入解释成有符号十进制整数
            - %o把输入解释成有符号八进制整数
            - %p把输入解释成指针（地址）
            - %s把输入解释成字符串。从第1个非空白字符开始，到下一个空白字符之前的所有字符
            - %u把输入解释成无符号十进制整数
            - %x、%X把输入解释成有符号十六进制整数
        - 常用修饰符
            - 把`*`放在%和转换字符之间时，会使得 scanf()跳过相应的输出项
            - ![attachment/Pasted image 20220427212837.png](/img/user/attachment/Pasted%20image%2020220427212837.png)![attachment/Pasted image 20220427212847.png](/img/user/attachment/Pasted%20image%2020220427212847.png)
        - 使用注意
            - 当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上'\0'，让数组中的内容成为一个C字符串。
            - 如果使用带多个转换说明的scanf()，C规定在第1个出错处停止读取输入
            - scanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。 在依次把转换说明和字段匹配时跳过空白
    - 文件访问步骤
        - 0 文件指针
            - 来源
                - 在读写一个文件之前，必须用库函数fopen打开它。fopen用诸如x.c或y.c 这样的外部名与操作系统进行某些必要的连接和通信（我们不必关心其细节），并返回一个此后用于文件读写操作的指针。
            - 包含内容
                - 它指向一个包含 文件信息的结构，包括：缓冲区的位置、 缓冲区中当前所指向的字符、是正在读或还是止在写文件、文件是否出错或是否已经到达文件结尾等等。用户不必知道这些细节。因为<stdio.h>中定义了一个含这些信息的结构FILE（他是通过tyoedef定义的新类型）
            - 声明
                - `FILE *fp` FILE是类型名，而不是结构标记
        - 1 访问文件——库函数fopen
            - 形式
                - fp=fopen（name，mode) ;
                - fopen的第一个参数是一个字符串，它包含文件名。第二个参数是访问模式，也是一个字符串，用于指定文件的使用方式。允许的模式包括：读（“r”）、写（“w”）及追加（“a”）
        - 2 读写文件——库函数getc和getc（也可以作为宏）
            - ![attachment/Pasted image 20220428032811.png](/img/user/attachment/Pasted%20image%2020220428032811.png)
                - getc 函数返回文件指针指向的输入流中的下一个字符。如果到达文件尾或出现错误，该函数将返回 EOF
            - ![attachment/Pasted image 20220428032825.png](/img/user/attachment/Pasted%20image%2020220428032825.png)
                - putc函数将字名到文件指针指向的文件中，并返回写入的字符。如果发生错误将返回EOF。
            - getchar和putchar
                - 用getc、putc、stdin及stdout函数定义，`define getchar()  get(stdin〉 #define putchar(c) putc(c),stdout)`
                    - 当一个c程序开始运行时，操作系统环境负责打开3个文件并将3个文件的指针提供给程序。这些 文件是标准输入、标准输出和标准错误、其相应的指针分别为stdin、stdout和stderr，它们在 <stdio.h>中说明。在大多数环境中，stdin指向键盘，而stdout和stderr则指向显示器。
        - 3 对于文件的格式化输入或输出
            - 可以使用函数 fscanf 和 fprintf。它们与 scanf 和printf函数的区别仅仅在于它们的第一个参数是一个指向所要读写的文件的指针,第二个参数是格式串。
- UNIX系统界面










## 术语表

###### 变量（变元）
在函数之间进行数据通信的一种方法是让调用函数向被调用函数提供一串叫做变元的值。 函数名后面的一对圆括号用于把这一串变元（变元表）括起来
###### 自动变量
即局部变量，函数中的每一个局部变量只在该函数被调用时存在，在该函数执行完退出时消失。由于自动变量只在函数调用执行期间存在，故在函数的两次调用期间，白动变量不保留在前次调用时所赋的值
###### 调用
在局部范围内复制并使用